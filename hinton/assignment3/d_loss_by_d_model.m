function ret = d_loss_by_d_model(model, data, wd_coefficient)  % model.input_to_hid is a matrix of size <number of hidden units> by <number of inputs i.e. 256>  % model.hid_to_class is a matrix of size <number of classes i.e. 10> by <number of hidden units>  % data.inputs is a matrix of size <number of inputs i.e. 256> by <number of data cases>. Each column describes a different data case.   % data.targets is a matrix of size <number of classes i.e. 10> by <number of data cases>. Each column describes a different data case. It contains a one-of-N encoding of the class, i.e. one element in every column is 1 and the others are 0.  % The returned object is supposed to be exactly like parameter <model>, i.e. it has fields ret.input_to_hid and ret.hid_to_class. However, the contents of those matrices are gradients (d loss by d model parameter), instead of model parameters.	   % This is the only function that you're expected to change. Right now, it just returns a lot of zeros, which is obviously not the correct output. Your job is to replace that by a correct computation.    m = size(data.inputs,2);  hid_input = model.input_to_hid * data.inputs;  hid_output = logistic(hid_input);  class_input = model.hid_to_class * hid_output;  class_normalizer = log_sum_exp_over_rows(class_input);  log_class_prob = class_input -repmat(class_normalizer,[size(class_input,1),1]);  class_output = exp(log_class_prob);    delta_3 = class_output - data.targets;  temp = logistic(hid_input);  temp1 = 1 - logistic(hid_input);  temp2 = logistic(hid_input) .*(1-logistic(hid_input));  fprintf('d_loss_by_d_model: temp %dx%d, temp1 %dx%d, temp2 %dx%d\n', rows(temp),columns(temp),rows(temp1),columns(temp1),rows(temp2),columns(temp2))  delta_2 = (model.hid_to_class' * delta_3) .* (logistic(hid_input) .*(1-logistic(hid_input)));      ret.input_to_hid = (1 / m) .* (delta_2 * data.inputs') + wd_coefficient.* model.input_to_hid;  ret.hid_to_class =(1 / m) .* (delta_3 * hid_output') + wd_coefficient.* model.hid_to_class;  %ret.input_to_hid = (1 / n_training_cases) .* (delta_2 * data.inputs') + wd_coefficient.* model.input_to_hid;  %ret.hid_to_class =(1 / n_training_cases) .* (delta_3 * hid_output') + wd_coefficient.* model.hid_to_class;end